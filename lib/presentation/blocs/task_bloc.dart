import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/task.dart';
import '../../domain/usecases/get_all_tasks_use_case.dart';
import '../../domain/usecases/get_tasks_by_workspace_id_use_case.dart';
import '../../domain/usecases/create_task_use_case.dart';
import '../../domain/usecases/update_task_use_case.dart';
import '../../domain/usecases/delete_task_use_case.dart';
import '../../domain/repositories/task_repository.dart';
import '../../domain/repositories/tag_repository.dart';
import '../../data/services/notification_service.dart';
import '../../core/app_state_provider.dart';
import 'task_event.dart';
import 'task_state.dart';

/// Task BLoC - Business Logic Component for task management
/// Handles all task-related events and emits corresponding states
/// Follows BLoC pattern with Clean Architecture
class TaskBloc extends Bloc<TaskEvent, TaskState> {
  final GetAllTasksUseCase getAllTasksUseCase;
  final GetTasksByWorkspaceIdUseCase getTasksByWorkspaceIdUseCase;
  final CreateTaskUseCase createTaskUseCase;
  final UpdateTaskUseCase updateTaskUseCase;
  final DeleteTaskUseCase deleteTaskUseCase;
  final TaskRepository taskRepository;
  final TagRepository tagRepository;
  final AppStateProvider appStateProvider;

  TaskBloc({
    required this.getAllTasksUseCase,
    required this.getTasksByWorkspaceIdUseCase,
    required this.createTaskUseCase,
    required this.updateTaskUseCase,
    required this.deleteTaskUseCase,
    required this.taskRepository,
    required this.tagRepository,
    required this.appStateProvider,
  }) : super(const TaskInitial()) {
    // Register event handlers
    on<LoadTasksEvent>(_onLoadTasks);
    on<LoadTasksByWorkspaceEvent>(_onLoadTasksByWorkspace);
    on<LoadFilteredTasksEvent>(_onLoadFilteredTasks);
    on<CreateTaskEvent>(_onCreateTask);
    on<UpdateTaskEvent>(_onUpdateTask);
    on<DeleteTaskEvent>(_onDeleteTask);
    on<ToggleTaskCompletionEvent>(_onToggleTaskCompletion);
    on<DeleteCompletedTasksEvent>(_onDeleteCompletedTasks);
    on<SearchTasksEvent>(_onSearchTasks);
    on<FilterTasksByPriorityEvent>(_onFilterTasksByPriority);
    on<FilterTasksByCategoryEvent>(_onFilterTasksByCategory);
    on<FilterTasksByDateRangeEvent>(_onFilterTasksByDateRange);
    on<LoadTodayTasksEvent>(_onLoadTodayTasks);
    on<LoadOverdueTasksEvent>(_onLoadOverdueTasks);
    on<LoadCompletedTasksEvent>(_onLoadCompletedTasks);
    on<LoadPendingTasksEvent>(_onLoadPendingTasks);
  }

  /// Load all tasks
  Future<void> _onLoadTasks(
    LoadTasksEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final tasks = await getAllTasksUseCase();

      if (tasks.isEmpty) {
        emit(const TaskEmpty());
      } else {
        emit(TaskLoaded(tasks: tasks, currentFilter: TaskFilter.all));
      }
    } catch (e) {
      emit(
        TaskError(message: 'Failed to load tasks', errorDetails: e.toString()),
      );
    }
  }

  /// Load tasks by workspace ID
  Future<void> _onLoadTasksByWorkspace(
    LoadTasksByWorkspaceEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final tasks = await getTasksByWorkspaceIdUseCase(event.workspaceId);

      if (tasks.isEmpty) {
        emit(const TaskEmpty(message: 'No tasks found for this workspace'));
      } else {
        emit(TaskLoaded(tasks: tasks, currentFilter: TaskFilter.all));
      }
    } catch (e) {
      emit(
        TaskError(message: 'Failed to load workspace tasks', errorDetails: e.toString()),
      );
    }
  }

  /// Load filtered tasks based on filter type
  Future<void> _onLoadFilteredTasks(
    LoadFilteredTasksEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      List<Task> tasks;

      switch (event.filter) {
        case TaskFilter.all:
          tasks = await getAllTasksUseCase();
          break;
      }

      // Filter by workspace if specified
      if (event.workspaceId != null) {
        tasks = tasks.where((task) => task.workspaceId == event.workspaceId).toList();
      }

      if (tasks.isEmpty) {
        emit(TaskEmpty(message: 'No ${event.filter.name} tasks found'));
      } else {
        emit(TaskLoaded(tasks: tasks, currentFilter: event.filter));
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to load filtered tasks',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Create a new task
  Future<void> _onCreateTask(
    CreateTaskEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskOperationInProgress('Creating task...'));

      final newTask = Task(
        id: 0, // Will be auto-generated by Isar
        title: event.title,
        description: event.description,
        dueDate: event.dueDate,
        isCompleted: false,
        priority: event.priority,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        category: event.category,
        workspaceId: event.workspaceId,
        progress: 0.0,
        estimatedHours: 1,
        tagIds: event.tagIds,
      );

      await createTaskUseCase(newTask);

      // Update tag usage counters
      if (event.tagIds != null && event.tagIds!.isNotEmpty) {
        for (final tagId in event.tagIds!) {
          await tagRepository.incrementTagUsage(tagId);
        }
        // Mark tags for refresh
        appStateProvider.markTagsNeedRefresh();
      }

      // Schedule notification for the task if it has a due date
      if (event.dueDate.isAfter(DateTime.now())) {
        final notificationService = NotificationService();
        await notificationService.scheduleTaskReminder(
          task: newTask,
          beforeDueDate: const Duration(hours: 1), // Remind 1 hour before
        );
        
        // Also schedule multiple reminders
        await notificationService.scheduleMultipleReminders(
          task: newTask,
          reminderDurations: const [
            Duration(days: 1),    // 1 day before
            Duration(hours: 3),   // 3 hours before
            Duration(hours: 1),   // 1 hour before
          ],
        );
      }

      // Reload tasks for the specific workspace if workspaceId is provided
      if (event.workspaceId != null) {
        final tasks = await getTasksByWorkspaceIdUseCase(event.workspaceId!);
        emit(TaskLoaded(tasks: tasks, currentFilter: TaskFilter.all));
      } else {
        // Reload all tasks if no workspace specified
        final tasks = await getAllTasksUseCase();
        emit(
          TaskOperationSuccess(
            message: 'Task created successfully',
            tasks: tasks,
          ),
        );
      }
    } catch (e) {
      emit(
        TaskError(message: 'Failed to create task', errorDetails: e.toString()),
      );
    }
  }

  /// Update an existing task
  Future<void> _onUpdateTask(
    UpdateTaskEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskOperationInProgress('Updating task...'));

      // Автоматически отмечаем задачу как выполненную, если прогресс >= 100%
      final taskToUpdate = event.task.progress != null && event.task.progress! >= 1.0
          ? event.task.copyWith(isCompleted: true)
          : event.task;

      // Get the original task to compare tag changes
      final originalTask = await taskRepository.getTaskById(event.task.id);
      
      await updateTaskUseCase(taskToUpdate);

      // Update tag usage counters if tags changed
      if (originalTask != null) {
        final oldTagIds = originalTask.tagIds ?? [];
        final newTagIds = event.task.tagIds ?? [];
        
        // Decrement usage for removed tags
        for (final tagId in oldTagIds) {
          if (!newTagIds.contains(tagId)) {
            await tagRepository.decrementTagUsage(tagId);
          }
        }
        
        // Increment usage for new tags
        for (final tagId in newTagIds) {
          if (!oldTagIds.contains(tagId)) {
            await tagRepository.incrementTagUsage(tagId);
          }
        }
        
        // Mark tags for refresh if any changes were made
        if (oldTagIds.isNotEmpty || newTagIds.isNotEmpty) {
          appStateProvider.markTagsNeedRefresh();
        }
      }

      // Reload tasks for the specific workspace if workspaceId is provided
      if (event.task.workspaceId != null) {
        final tasks = await getTasksByWorkspaceIdUseCase(event.task.workspaceId!);
        emit(TaskLoaded(tasks: tasks, currentFilter: TaskFilter.all));
      } else {
        // Reload all tasks if no workspace specified
        final tasks = await getAllTasksUseCase();
        emit(
          TaskOperationSuccess(
            message: 'Task updated successfully',
            tasks: tasks,
          ),
        );
      }
    } catch (e) {
      emit(
        TaskError(message: 'Failed to update task', errorDetails: e.toString()),
      );
    }
  }

  /// Delete a task
  Future<void> _onDeleteTask(
    DeleteTaskEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskOperationInProgress('Deleting task...'));

      // Get the task before deletion to update tag usage counters
      final taskToDelete = await taskRepository.getTaskById(event.taskId);
      
      await deleteTaskUseCase(event.taskId);

      // Update tag usage counters
      if (taskToDelete != null && taskToDelete.tagIds != null && taskToDelete.tagIds!.isNotEmpty) {
        for (final tagId in taskToDelete.tagIds!) {
          await tagRepository.decrementTagUsage(tagId);
        }
        // Mark tags for refresh
        appStateProvider.markTagsNeedRefresh();
      }

      // Reload all tasks after deletion
      final tasks = await getAllTasksUseCase();

      if (tasks.isEmpty) {
        emit(const TaskEmpty());
      } else {
        emit(
          TaskOperationSuccess(
            message: 'Task deleted successfully',
            tasks: tasks,
          ),
        );

        // Transition to loaded state
      }
    } catch (e) {
      emit(
        TaskError(message: 'Failed to delete task', errorDetails: e.toString()),
      );
    }
  }

  /// Toggle task completion status
  Future<void> _onToggleTaskCompletion(
    ToggleTaskCompletionEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      await taskRepository.toggleTaskCompletion(event.taskId);

      // Reload all tasks after toggling
      final tasks = await getAllTasksUseCase();
      emit(TaskLoaded(tasks: tasks, currentFilter: TaskFilter.all));
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to toggle task completion',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Delete all completed tasks
  Future<void> _onDeleteCompletedTasks(
    DeleteCompletedTasksEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskOperationInProgress('Deleting completed tasks...'));

      await taskRepository.deleteCompletedTasks();

      // Reload all tasks after deletion
      final tasks = await getAllTasksUseCase();

      if (tasks.isEmpty) {
        emit(const TaskEmpty());
      } else {
        emit(
          TaskOperationSuccess(
            message: 'Completed tasks deleted',
            tasks: tasks,
          ),
        );

        // Transition to loaded state
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to delete completed tasks',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Search tasks by query
  Future<void> _onSearchTasks(
    SearchTasksEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final tasks = await taskRepository.searchTasks(event.query);

      if (tasks.isEmpty) {
        emit(TaskEmpty(message: 'No tasks found for "${event.query}"'));
      } else {
        emit(TaskLoaded(tasks: tasks, searchQuery: event.query));
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to search tasks',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Filter tasks by priority
  Future<void> _onFilterTasksByPriority(
    FilterTasksByPriorityEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final tasks = await taskRepository.getTasksByPriority(event.priority);

      if (tasks.isEmpty) {
        emit(
          TaskEmpty(
            message: 'No ${event.priority.displayName} priority tasks found',
          ),
        );
      } else {
        emit(TaskLoaded(tasks: tasks));
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to filter tasks by priority',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Filter tasks by category
  Future<void> _onFilterTasksByCategory(
    FilterTasksByCategoryEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final tasks = await taskRepository.getTasksByCategory(event.category);

      if (tasks.isEmpty) {
        emit(TaskEmpty(message: 'No tasks found in "${event.category}"'));
      } else {
        emit(TaskLoaded(tasks: tasks));
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to filter tasks by category',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Filter tasks by date range
  Future<void> _onFilterTasksByDateRange(
    FilterTasksByDateRangeEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final tasks = await taskRepository.getTasksByDateRange(
        event.startDate,
        event.endDate,
      );

      if (tasks.isEmpty) {
        emit(const TaskEmpty(message: 'No tasks found in this date range'));
      } else {
        emit(TaskLoaded(tasks: tasks));
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to filter tasks by date range',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Load today's tasks
  Future<void> _onLoadTodayTasks(
    LoadTodayTasksEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final now = DateTime.now();
      final startOfDay = DateTime(now.year, now.month, now.day);
      final endOfDay = startOfDay.add(const Duration(days: 1));

      final tasks = await taskRepository.getTasksByDateRange(
        startOfDay,
        endOfDay,
      );

      if (tasks.isEmpty) {
        emit(const TaskEmpty(message: 'No tasks for today'));
      } else {
        emit(TaskLoaded(tasks: tasks, currentFilter: TaskFilter.all));
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to load today\'s tasks',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Load overdue tasks
  Future<void> _onLoadOverdueTasks(
    LoadOverdueTasksEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final allTasks = await getAllTasksUseCase();
      final now = DateTime.now();

      final overdueTasks = allTasks
          .where((task) => task.dueDate.isBefore(now) && !task.isCompleted)
          .toList();

      if (overdueTasks.isEmpty) {
        emit(const TaskEmpty(message: 'No overdue tasks'));
      } else {
        emit(
          TaskLoaded(tasks: overdueTasks, currentFilter: TaskFilter.all),
        );
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to load overdue tasks',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Load completed tasks
  Future<void> _onLoadCompletedTasks(
    LoadCompletedTasksEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final tasks = await taskRepository.getCompletedTasks();

      if (tasks.isEmpty) {
        emit(const TaskEmpty(message: 'No completed tasks'));
      } else {
        emit(TaskLoaded(tasks: tasks, currentFilter: TaskFilter.all));
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to load completed tasks',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Load pending tasks
  Future<void> _onLoadPendingTasks(
    LoadPendingTasksEvent event,
    Emitter<TaskState> emit,
  ) async {
    try {
      emit(const TaskLoading());

      final tasks = await taskRepository.getPendingTasks();

      if (tasks.isEmpty) {
        emit(const TaskEmpty(message: 'No pending tasks'));
      } else {
        emit(TaskLoaded(tasks: tasks, currentFilter: TaskFilter.all));
      }
    } catch (e) {
      emit(
        TaskError(
          message: 'Failed to load pending tasks',
          errorDetails: e.toString(),
        ),
      );
    }
  }
}
