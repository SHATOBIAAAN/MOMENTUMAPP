import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/workspace.dart';
import '../../domain/usecases/get_all_workspaces_use_case.dart';
import '../../domain/usecases/create_workspace_use_case.dart';
import '../../domain/usecases/update_workspace_use_case.dart';
import '../../domain/usecases/delete_workspace_use_case.dart';
import '../../domain/repositories/workspace_repository.dart';
import 'workspace_event.dart';
import 'workspace_state.dart';

/// Workspace BLoC - Business Logic Component for workspace management
/// Handles all workspace-related events and emits corresponding states
class WorkspaceBloc extends Bloc<WorkspaceEvent, WorkspaceState> {
  final GetAllWorkspacesUseCase getAllWorkspacesUseCase;
  final CreateWorkspaceUseCase createWorkspaceUseCase;
  final UpdateWorkspaceUseCase updateWorkspaceUseCase;
  final DeleteWorkspaceUseCase deleteWorkspaceUseCase;
  final WorkspaceRepository workspaceRepository;

  WorkspaceBloc({
    required this.getAllWorkspacesUseCase,
    required this.createWorkspaceUseCase,
    required this.updateWorkspaceUseCase,
    required this.deleteWorkspaceUseCase,
    required this.workspaceRepository,
  }) : super(const WorkspaceInitial()) {
    // Register event handlers
    on<LoadWorkspacesEvent>(_onLoadWorkspaces);
    on<CreateWorkspaceEvent>(_onCreateWorkspace);
    on<UpdateWorkspaceEvent>(_onUpdateWorkspace);
    on<DeleteWorkspaceEvent>(_onDeleteWorkspace);
    on<UpdateWorkspaceOrderEvent>(_onUpdateWorkspaceOrder);
    on<UpdateWorkspaceTaskCountsEvent>(_onUpdateWorkspaceTaskCounts);
  }

  /// Load all workspaces
  Future<void> _onLoadWorkspaces(
    LoadWorkspacesEvent event,
    Emitter<WorkspaceState> emit,
  ) async {
    try {
      emit(const WorkspaceLoading());

      final workspaces = await getAllWorkspacesUseCase();

      if (workspaces.isEmpty) {
        emit(const WorkspaceEmpty());
      } else {
        emit(WorkspaceLoaded(workspaces: workspaces));
      }
    } catch (e) {
      emit(
        WorkspaceError(message: 'Failed to load workspaces', errorDetails: e.toString()),
      );
    }
  }

  /// Create a new workspace
  Future<void> _onCreateWorkspace(
    CreateWorkspaceEvent event,
    Emitter<WorkspaceState> emit,
  ) async {
    try {
      emit(const WorkspaceOperationInProgress('Creating workspace...'));

      final newWorkspace = Workspace(
        id: 0, // Will be auto-generated by Isar
        name: event.name,
        description: event.description,
        iconName: event.iconName,
        colorHex: event.colorHex,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        order: 0, // Will be set by use case
        totalTasks: 0,
        completedTasks: 0,
      );

      await createWorkspaceUseCase(newWorkspace);

      // Reload all workspaces after creation
      final workspaces = await getAllWorkspacesUseCase();
      emit(
        WorkspaceOperationSuccess(
          message: 'Workspace created successfully',
          workspaces: workspaces,
        ),
      );
    } catch (e) {
      emit(
        WorkspaceError(message: 'Failed to create workspace', errorDetails: e.toString()),
      );
    }
  }

  /// Update an existing workspace
  Future<void> _onUpdateWorkspace(
    UpdateWorkspaceEvent event,
    Emitter<WorkspaceState> emit,
  ) async {
    try {
      emit(const WorkspaceOperationInProgress('Updating workspace...'));

      final existingWorkspace = await workspaceRepository.getWorkspaceById(event.id);
      if (existingWorkspace == null) {
        emit(const WorkspaceError(message: 'Workspace not found'));
        return;
      }

      final updatedWorkspace = existingWorkspace.copyWith(
        name: event.name,
        description: event.description,
        iconName: event.iconName,
        colorHex: event.colorHex,
      );

      await updateWorkspaceUseCase(updatedWorkspace);

      // Reload all workspaces after update
      final workspaces = await getAllWorkspacesUseCase();
      emit(
        WorkspaceOperationSuccess(
          message: 'Workspace updated successfully',
          workspaces: workspaces,
        ),
      );

      // Transition to loaded state
      emit(WorkspaceLoaded(workspaces: workspaces));
    } catch (e) {
      emit(
        WorkspaceError(message: 'Failed to update workspace', errorDetails: e.toString()),
      );
    }
  }

  /// Delete a workspace
  Future<void> _onDeleteWorkspace(
    DeleteWorkspaceEvent event,
    Emitter<WorkspaceState> emit,
  ) async {
    try {
      emit(const WorkspaceOperationInProgress('Deleting workspace...'));

      await deleteWorkspaceUseCase(event.workspaceId);

      // Reload all workspaces after deletion
      final workspaces = await getAllWorkspacesUseCase();

      if (workspaces.isEmpty) {
        emit(const WorkspaceEmpty());
      } else {
        emit(
          WorkspaceOperationSuccess(
            message: 'Workspace deleted successfully',
            workspaces: workspaces,
          ),
        );

        // Transition to loaded state
        emit(WorkspaceLoaded(workspaces: workspaces));
      }
    } catch (e) {
      emit(
        WorkspaceError(message: 'Failed to delete workspace', errorDetails: e.toString()),
      );
    }
  }

  /// Update workspace order
  Future<void> _onUpdateWorkspaceOrder(
    UpdateWorkspaceOrderEvent event,
    Emitter<WorkspaceState> emit,
  ) async {
    try {
      await workspaceRepository.updateWorkspaceOrder(event.workspaceId, event.newOrder);

      // Reload all workspaces after order update
      final workspaces = await getAllWorkspacesUseCase();
      emit(WorkspaceLoaded(workspaces: workspaces));
    } catch (e) {
      emit(
        WorkspaceError(
          message: 'Failed to update workspace order',
          errorDetails: e.toString(),
        ),
      );
    }
  }

  /// Update workspace task counts
  Future<void> _onUpdateWorkspaceTaskCounts(
    UpdateWorkspaceTaskCountsEvent event,
    Emitter<WorkspaceState> emit,
  ) async {
    try {
      await workspaceRepository.updateWorkspaceTaskCounts(
        event.workspaceId,
        event.totalTasks,
        event.completedTasks,
      );

      // Reload all workspaces after task count update
      final workspaces = await getAllWorkspacesUseCase();
      emit(WorkspaceLoaded(workspaces: workspaces));
    } catch (e) {
      emit(
        WorkspaceError(
          message: 'Failed to update workspace task counts',
          errorDetails: e.toString(),
        ),
      );
    }
  }
}
